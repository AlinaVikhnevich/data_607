---
title: "DATA 607 Final Project: Pop Culture & Public Search Behavior"
author: "Group Members: Alina Vikhnevich, Olivia Azevedo, Alyssa Gurkas"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Packages

```{r setup, message=FALSE, warning=FALSE}
library(bigrquery)
library(DBI)
library(dplyr)
library(ggplot2)
library(tidyr)
library(tidytext)
library(lubridate)
library(stringr)
library(wordcloud)
library(topicmodels)
library(readr)
```

This project uses several R packages to support data acquisition,
cleaning, analysis, and visualization. For example, `bigrquery` and
`DBI` are used to query data from Google BigQuery, `tidytext` enables
text mining and topic modeling, and `ggplot2` is used for data
visualization.

# Introduction

In this project, we explore how search behavior in the United States
reflects interest in major pop culture events. Using unsupervised topic
modeling, we analyze Google’s top search terms to identify recurring
themes and trends. By linking search activity with globally documented
events, we aim to uncover how societal attention manifests in digital
behavior.

## Data Sources

-   **Google BigQuery – Top 25 Search Terms**\
    Google’s public dataset on the top 25 search queries per day,
    available via BigQuery.
-   **GDELT 2.0 – Our Global World in Realtime**\
    A large-scale global event database tracking news events from around
    the world in real time, including media coverage of pop culture,
    conflict, disasters, and more.

## Data Acquisition

### 1. Google BigQuery – Top 25 Search Terms

We use the `bigrquery` package to access Google’s public dataset of the
most popular daily search terms. Make sure you have a Google Cloud
project set up with billing enabled and a BigQuery API key.

```{r bigquery-auth, eval=FALSE}
# Authenticate with Google Cloud (interactive)
bq_auth(path = "data607finalproject-6c666e5b6214.json")
```

```{r google-bigquery-api}
project_id <- "data607finalproject"

query <- "
WITH rising AS (
  SELECT
    week,
    refresh_date,
    ARRAY_AGG(DISTINCT term) AS terms
  FROM `bigquery-public-data.google_trends.top_rising_terms`
  WHERE refresh_date = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)
  GROUP BY week, refresh_date
)

SELECT
  top.refresh_date,
  top.week,
  top.dma_name,
  top.dma_id,
  top.term AS top_term,
  top.score AS top_score,
  top.rank AS top_rank,
  rising.terms AS rising_terms
FROM `bigquery-public-data.google_trends.top_terms` top
JOIN rising
ON top.refresh_date = rising.refresh_date AND top.week = rising.week
ORDER BY week DESC, refresh_date DESC
"

google_search_data <- bq_project_query(project_id, query)
google_search_df <- bq_table_download(google_search_data)

head(google_search_df)
```

**Unnest the `rising_terms` list column**

This will create a long-format dataframe where each rising term is a
separate row.

```{r rising-unnest}
# Unnesting the 'rising_terms' column so each term has its own row
rising_df <- google_search_df |>
  unnest(rising_terms)

head(rising_df)
```

**Count frequency of top search terms**

This shows how often each top-ranked term appeared across all DMAs and
dates in your sample.

```{r top-term-frequency}
# Count appearances of each top term
top_term_counts <- google_search_df |>
  count(top_term, sort = TRUE)

head(top_term_counts)
```

**Count frequency of rising terms**

This does the same for rising terms, now that we’ve unnested them.

```{r rising-term-frequency}
rising_term_counts <- rising_df |>
  count(rising_terms, sort = TRUE)

head(rising_term_counts)
```

**Preview which terms are most common**

These previews help you quickly spot which types of trends (e.g.,
sports, celebrity) show up the most.

```{r preview-trending-terms}
# View most frequent top and rising terms side-by-side
top_term_counts |> head(10)
rising_term_counts |> head(10)
```

### 2. GDELT 2.0: Our Global World in Realtime

**Getting the latest file name:**

```{r gdelt-latest-link}
# Get the name of the most recent GDELT CSV file
latest_file <- read_lines("http://data.gdeltproject.org/gdeltv2/lastupdate.txt")
latest_file
```

**Download and Unzip:**

```{r gdelt-download}
# Constructing the full URL to download the ZIP file
export_url_line <- latest_file[1]

# Extract the URL from the line using strsplit
export_url <- strsplit(export_url_line, " ")[[1]][3]
export_url

# Download the export ZIP file to your working directory
download.file(export_url, destfile = "gdelt_latest.zip", mode = "wb")

# Unzip the file
unzip("gdelt_latest.zip")
```

**Read CSV into R:**

```{r gdelt-read}
# Extract filename only from URL
csv_file <- gsub(".zip", "", basename(export_url))

# Read the CSV file with correct case-sensitive name
gdelt_df <- read_csv(csv_file, col_names = FALSE)

# Preview data
head(gdelt_df)
```

**GDELT 2.0 – Structured Load & Exploration**

GDELT 2.0 is a massive global event database that captures media
coverage of events in real time from across the world. The export files
are updated every 15 minutes and are tab-delimited without column
headers, so we must assign names manually using the GDELT schema.

In this chunk, we load the most recent export file and apply column
names for easier exploration:

```{r}
# Column names based on GDELT 2.0 schema (first 10 for demo, full list has 58+)
gdelt_cols <- c(
  "GLOBALEVENTID", "Day", "MonthYear", "Year", "FractionDate", 
  "Actor1Code", "Actor1Name", "Actor1CountryCode", "Actor1KnownGroupCode", 
  "Actor1EthnicCode", "Actor1Religion1Code", "Actor1Religion2Code", 
  "Actor1Type1Code", "Actor1Type2Code", "Actor1Type3Code",
  "Actor2Code", "Actor2Name", "Actor2CountryCode", "Actor2KnownGroupCode", 
  "Actor2EthnicCode", "Actor2Religion1Code", "Actor2Religion2Code", 
  "Actor2Type1Code", "Actor2Type2Code", "Actor2Type3Code",
  "IsRootEvent", "EventCode", "EventBaseCode", "EventRootCode", 
  "QuadClass", "GoldsteinScale", "NumMentions", "NumSources", 
  "NumArticles", "AvgTone", "Actor1Geo_Type", "Actor1Geo_FullName", 
  "Actor1Geo_CountryCode", "Actor1Geo_ADM1Code", "Actor1Geo_Lat", 
  "Actor1Geo_Long", "Actor1Geo_FeatureID", "Actor2Geo_Type", 
  "Actor2Geo_FullName", "Actor2Geo_CountryCode", "Actor2Geo_ADM1Code", 
  "Actor2Geo_Lat", "Actor2Geo_Long", "Actor2Geo_FeatureID", 
  "ActionGeo_Type", "ActionGeo_FullName", "ActionGeo_CountryCode", 
  "ActionGeo_ADM1Code", "ActionGeo_Lat", "ActionGeo_Long", 
  "ActionGeo_FeatureID", "DATEADDED", "SOURCEURL"
)

# Read the file with tab delimiter and custom column names
gdelt_df <- read_delim(csv_file, delim = "\t", col_names = gdelt_cols, show_col_types = FALSE)

# Preview first rows
head(gdelt_df)
```
